namespace StaticGenerators;

using System.Text;

public class PinnedArrayGeneratorParameters {
    public string ClassName;
    public string DataType;
    public string Namespace;
    public string Modifier = "public";
    
    public string[] ExtraUsings;
    
    public bool GenerateEnumerator;
}

public class PinnedArrayGenerator {
    private readonly PinnedArrayGeneratorParameters parameters;
    
    public PinnedArrayGenerator(Action<PinnedArrayGeneratorParameters> parameters) {
        this.parameters = new PinnedArrayGeneratorParameters();
        parameters.Invoke(this.parameters);
    }

    public void Run(string path) {
        var code = this.GenerateCode();
        File.WriteAllText(Utilities.GetPathInSolution(path), code);
        Console.WriteLine($"[PinnedArrayGenerator] Generated: {path}");
    }

    private string GenerateCode() =>
$@"// Generated by StaticGenerators/PinnedArrayGenerator.cs

#if ENABLE_MONO || ENABLE_IL2CPP
#define MORPEH_UNITY
#endif

namespace {this.parameters.Namespace} {{
    using System;
    using System.Runtime.CompilerServices;
#if MORPEH_UNITY
    using Unity.Collections.LowLevel.Unsafe;
#else
    using System.Runtime.InteropServices;
#endif
    using Unity.IL2CPP.CompilerServices;

    // START: Extra usings
{this.GenerateExtraUsings(indent: 1)}
    // END: Extra usings

    [Il2CppSetOption(Option.NullChecks, false)]
    [Il2CppSetOption(Option.ArrayBoundsChecks, false)]
    [Il2CppSetOption(Option.DivideByZeroChecks, false)]
    {this.parameters.Modifier} unsafe struct {this.parameters.ClassName} : IDisposable {{
        public {this.parameters.DataType}[] data;
        public {this.parameters.DataType}* ptr;
#if MORPEH_UNITY
        public ulong handle;
#else
        public GCHandle handle;
#endif
        
        public {this.parameters.DataType} this[int index] {{
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => this.data[index];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => this.data[index] = value;
        }}
        
        public int Length => this.data.Length;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {this.parameters.ClassName}(int size) {{
            this.data = new {this.parameters.DataType}[size];
#if MORPEH_UNITY
            this.ptr = ({this.parameters.DataType}*)UnsafeUtility.PinGCArrayAndGetDataAddress(this.data, out this.handle);
#else
            this.handle = GCHandle.Alloc(this.data, GCHandleType.Pinned);
            this.ptr = ({this.parameters.DataType}*)this.handle.AddrOfPinnedObject();
#endif
        }}

        [MethodImpl(MethodImplOptions.NoInlining)]
        public void Resize(int newSize) {{
#if MORPEH_UNITY
            UnsafeUtility.ReleaseGCObject(this.handle);
#else
            this.handle.Free();
#endif
            var newArray = new {this.parameters.DataType}[newSize];
            var len = this.data.Length;
            Array.Copy(this.data, 0, newArray, 0, newSize >= len ? len : newSize);
            this.data = newArray;
#if MORPEH_UNITY
            this.ptr = ({this.parameters.DataType}*)UnsafeUtility.PinGCArrayAndGetDataAddress(this.data, out this.handle);
#else
            this.handle = GCHandle.Alloc(newArray, GCHandleType.Pinned);
            this.ptr = ({this.parameters.DataType}*)this.handle.AddrOfPinnedObject();
#endif
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear() {{
            Array.Clear(this.data, 0, this.data.Length);
        }}
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose() {{
#if MORPEH_UNITY
            UnsafeUtility.ReleaseGCObject(this.handle);
            this.ptr = ({this.parameters.DataType}*)IntPtr.Zero;
            this.data = null;
#else
            if (this.handle.IsAllocated) {{
                this.handle.Free();
                this.ptr = ({this.parameters.DataType}*)IntPtr.Zero;
                this.data = null;
            }}
#endif
        }}

        // START: Enumerator
{this.GenerateEnumerator()}
        // END: Enumerator
    }}
}}";
    
    private string GenerateExtraUsings(int indent = 0) {
        if (this.parameters.ExtraUsings == null || this.parameters.ExtraUsings.Length == 0) {
            return string.Empty;
        }
        
        var builder = new StringBuilder();
        foreach (var extraUsing in this.parameters.ExtraUsings) {
            builder.Append('\t', indent);
            builder.AppendLine($"using {extraUsing};");
        }
        return builder.ToString();
    }

    private string GenerateEnumerator() {
        if (!this.parameters.GenerateEnumerator) {
            return string.Empty;
        }

        return $@"      [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator GetEnumerator() {{
            Enumerator e;
            e.index  = -1;
            e.length = this.data.Length;
            e.ptr = this.ptr;
            return e;
        }}
        
        [Il2CppSetOption(Option.NullChecks, false)]
        [Il2CppSetOption(Option.ArrayBoundsChecks, false)]
        [Il2CppSetOption(Option.DivideByZeroChecks, false)]
        public struct Enumerator {{
            public int index;
            public int length;
            public {this.parameters.DataType}* ptr;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext() {{
                return ++this.index < this.length;
            }}

            public {this.parameters.DataType} Current {{
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => this.ptr[this.index];
            }}
        }}";
    }
}